### 常见的删除策略

常见的删除策略有以下3种：

1. 定时删除

   在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

2. 惰性删除

   放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键。

3. 定期删除

   每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定。

其中定时删除和定期删除为主动删除策略，惰性删除为被动删除策略。

#### 定时删除策略

定时删除策略通过使用定时器，定时删除策略可以保证过期键尽可能快地被删除，并释放过期键占用的内存。

因此，定时删除策略的优缺点如下所示：

1. 优点：对内存非常友好
2. 缺点：对CPU时间非常不友好

举个例子，如果有大量的命令请求等待服务器处理，并且服务器当前不缺少内存，如果服务器将大量的CPU时间用来删除过期键，那么服务器的响应时间和吞吐量就会受到影响。

也就是说，如果服务器创建大量的定时器，服务器处理命令请求的性能就会降低

因此Redis目前并没有使用定时删除策略。

#### 惰性删除策略

惰性删除策略只会在获取键时才对键进行过期检查，不会在删除其它无关的过期键花费过多的CPU时间。

因此，惰性删除策略的优缺点如下所示：

1. 优点：对CPU时间非常友好
2. 缺点：对内存非常不友好

举个例子，如果数据库有很多的过期键，而这些过期键又恰好一直没有被访问到，那这些过期键就会一直占用着宝贵的内存资源，造成资源浪费。

#### 定期删除策略

定期删除策略是定时删除策略和惰性删除策略的一种整合折中方案。

定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，同时，通过定期删除过期键，也有效地减少了因为过期键而带来的内存浪费。

## Redis使用的过期键删除策略

Redis服务器使用的是惰性删除策略和定期删除策略。

#### 惰性删除策略的实现

过期键的惰性删除策略由`expireIfNeeded`函数实现，所有读写数据库的Redis命令在执行之前都会调用`expireIfNeeded`函数对输入键进行检查：

- 如果输入键已经过期，那么将输入键从数据库中删除
- 如果输入键未过期，那么不做任何处理

![image-20220126120355386](https://images-1258301517.cos.ap-nanjing.myqcloud.com/images/202201261203429.png)

#### 定期删除策略的实现

过期键的定期删除策略由`activeExpireCycle`函数实现，每当Redis服务器的周期性操作`serverCron`函数执行时，`activeExpireCycle`函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的`expires`字典中**随机检查**一部分键的过期时间，并删除其中的过期键。

`activeExpireCycle`函数的大体流程为：

函数每次运行时，都从一定数量的数据库中随机取出一定数量的键进行检查，并删除其中的过期键，比如先从0号数据库开始检查，下次函数运行时，可能就是从1号数据库开始检查，直到15号数据库检查完毕，又重新从0号数据库开始检查，这样可以保证每个数据库都被检查到。

> 1. 关于定期删除的大体流程，最近面试时有被问道，我就是按上述描述回答的。
> 2. 可能有的面试官还会问，每次随机删除哪些key呢？可以提下LRU算法（Least Recently Used 最近最少使用

### RDB对过期键的处理

#### 生成RDB文件

在执行`SAVE`命令或者`BGSAVE`命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，**已过期的键不会被保存到新创建的RDB文件中**。

举个例子，如果数据库中包含3个键k1、k2、k3，并且k2已经过期，那么创建新的RDB文件时，程序只会将k1和k3保存到RDB文件中，k2则会被忽略。

#### 载入RDB文件

在启动Redis服务器时，如果服务器只开启了RDB持久化，那么服务器将会载入RDB文件：

- 如果服务器以**主服务器**模式运行，在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，过期键会被忽略。

- 如果服务器以**从服务器**模式运行，在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。

  > 因为主从服务器在进行数据同步（完整重同步）的时候，从服务器的数据库会被清空，所以一般情况下，过期键对载入RDB文件的从服务器不会造成影响。

### AOF对过期键的处理

#### AOF文件写入

如果数据库中的某个键已经过期，并且服务器开启了AOF持久化功能，当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条`DEL`命令，显式记录该键已被删除。

举个例子，如果客户端执行命令`GET message`访问已经过期的message键，那么服务器将执行以下3个动作：

1. 从数据库中删除message键
2. 追加一条`DEL message`命令到AOF文件
3. 向执行`GET message`命令的客户端返回空回复

#### AOF文件重写

在执行AOF文件重写时，程序会对数据库中的键进行检查，**已过期的键不会被保存到重写后的AOF文件中**。

### 复制功能对过期键的处理

**在主从复制模式下，从服务器的过期键删除动作由主服务器控制**：

- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
- 从服务器在执行客户端发送的读命令时，即使发现该键已过期也不会删除该键，照常返回该键的值。
- 从服务器只有接收到主服务器发送的DEL命令后，才会删除过期键。

### 内存淘汰策略

1. volatile-lru：从设置过期时间的数据集(server.db[i].expires)中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。

2. volatile-ttl：除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。

3. volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。

4. allkeys-lru：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。

5. allkeys-random：从数据集(server.db[i].dict)中选择任意数据淘汰。

6. no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。
7. volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
8. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

#### LRU淘汰

LRU(Least recently used，最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

在服务器配置中保存了 lru 计数器 server.lrulock，会定时(redis 定时程序 serverCorn())更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除。另外，从 struct redisObject 中可以发现，每一个 redis 对象都会设置相应的 lru。每一次访问数据，会更新对应redisObject.lru。

在Redis中，LRU算法是一个近似算法，默认情况下，Redis会随机挑选5个键，并从中选择一个最久未使用的key进行淘汰。在配置文件中，按maxmemory-samples选项进行配置，选项配置越大，消耗时间就越长，但结构也就越精准。 

#### TTL淘汰

Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl ***的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。

#### 随机淘汰

在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。

Redis中的淘汰机制都是几近于算法实现的，主要从性能和可靠性上做平衡，所以并不是完全可靠，所以开发者们在充分了解Redis淘汰策略之后还应在平时多主动设置或更新key的expire时间，主动删除没有价值的数据，提升Redis整体性能和空间。

