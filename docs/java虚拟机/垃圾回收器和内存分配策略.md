### 概述

想要了解垃圾回收，首先要清楚三件事

1. 哪些对象需要回收
2. 什么时候回收
3. 如何回收

为什么在内存技术相当成熟的今天，还需要去了解垃圾收集和内存分配？这是为了帮助我们在内存泄漏、内存溢出的时候能够很好的去调查原因。

**哪些对象需要回收**，脑海中浮现JVM内存区域的模型，其中程序计数器、本地方法栈、java虚拟机栈都是随着线程而生的，那么当线程结束的时候，这些内存都是会自己消失的，所以可以清楚的知道这几个区域的内存是会自己回收的。

java堆和方法区的内存就有着很明显的不确定性，java对存放的是对象实例，那么在程序运行的时候，会不断的产生对象，不管是小对象（几个字节）还是大对象（几兆甚至几十兆）都在不断的被生产，而方法区存放的是类的一些信息，可以想象如果使用动态创建类的方式，只有在运行期间才能清楚的知道创建了多少个类，所以说java堆和方法区的内存和回收是动态的，因而垃圾收集器关注的就是这部分内存区域。

### 如何判断对象已死

在垃圾回收之前，最重要的事情就是判断哪些对象需要回收，哪些对象不需要回收，如果随意的回收对象，只能造成程序的崩溃。

#### 引用计数法

对每一个对象都添加一个引用计数器，每当有一个地方引用它的话，引用计数器就加1，当引用不存的时候，引用计数器就减一，如果引用计数器为零，那么说明当前对象是可以被回收的。

引用计数法是通过占用额外的内存去确定对象是否存活，在某些情况下，它也是一个不错的选择，但是在实际情况下，程序需要做很多不必要的操作去确定对象是否存活，如两个对象的相互引用，但是这两个对象都是不再使用需要回收的对象，但是它们的程序计数器都是不为零的，因此垃圾回收器也是没法回收它们的。

```java
public class ReferenceObjectGc {

    private Object instance = null;

    @Test
    public void test(){
        ReferenceObjectGc referenceObjectGcA = new ReferenceObjectGc();
        ReferenceObjectGc referenceObjectGcB = new ReferenceObjectGc();
        referenceObjectGcA.instance = referenceObjectGcB;
        referenceObjectGcB.instance = referenceObjectGcA;
        System.gc();
    }
}

```

​ 上面的代码在实际的运行当中，垃圾是回收的，因为使用的判断方法不是程序计数法，而是使用的**可达性分析**。但是我们可以自己去考虑在**程序计数法**的情况下，这两个对象的存在情况

#### 可达性分析

通过**一系列**可以被称作**GC Roots**的根对象作为起始节点集，根据引用关系向下搜索，搜索过程所走过的路径成为“引用链”，如果某个对象到GC Roots间没有任何的引用链，那么证明该对象是不能被使用的对象。

<img src="https://gitee.com/gluten/images/raw/master/images/202110212153120.png" alt="image-20211019075426276" style="zoom:67%;" />

上面说到**GC Roots**是一系列的，那么可以作为GC Roots的对象包含以下几种：

- 在虚拟机栈（栈帧的本地变量表），如被线程调用的方法堆栈中的参数、局部变量、临时变量

- 在方法区中类静态属性引用的对象，如java类的引用类型静态变量

- 方法区中引用的常量，如常量池里的引用

- 在本地方法栈中native方法引用的对象

- java虚拟机内部的引用，如基本数据类型对象的Class对象，异常对象（NullPointException）等

- 所有被锁持有的对象

- 反应java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等

  除了上述这些情况外，还有一些对象是临时加入的，如分代收集和局部收集中，在针对垃圾回收的时候不仅要考虑自己本区域的垃圾收集细节，还要清楚的知道自己区域的对象有没有被其他区域引用。这时候就需要把这些关联的对象也一起加入到GC
  Roots的对象当中去。

#### 引用类型

仅仅只是通过引用链去判断是否已死，是一种狭隘的理解，如果一些对象在某些情况下存在引用，但是确实不需要的对象，那么根据引用链这种对象就是“食之无味弃之可惜”，所以针对这种情况，java对引用进行了扩充。将引用分为了强引用，软引用，弱引用和虚引用。

1. **强引用**

   只要还存在引用关系，那么垃圾回收器就永远不存回收该对象

2. **软引用**

   用来描述一些还有用，但是不是必须的对象，被软引用关联的对象，在出现内存溢出的时候，会把这些对象也纳入回收的范围，使用**SoftReference**类来实现软引用

3. **弱引用**

   弱引用用来描述那些没有作用的对象，对弱引用关联的对象只能存活到下次垃圾收集为止，使用**WeakReference**类来实现弱引用

4. **虚引用**

   一个对象是否存在虚引用不会对其生存时间造成任何的影响，也无法通过虚引用取得一个对象实例，为其设置一个虚引用的的目的是为了能在这个对象被收集的时候收到一个系统通知，使用**PhantomReference**来实现虚引用

#### finalize方法

如果对象不在引用链中也不能说这个对象是死亡的，要真正宣告一个对象的死亡，需要两步标记：第一个可达性分析，证明没有引用链，第二步确定该对象是否有必要执行**finalize**方法。

如果一个对象可以执行finalize**方法，那么这个对象会被放在一个**
F-Queue的对立中，稍后由虚拟机创建一个低调度优先级的Finalizer线程去执行finalize方法，一个对象执行了finalize，那么这个对象是可以被拯救的。

```java
public class FinalizeTest {

    public static FinalizeTest finalizeTest = null;


    public void isAlive(){
        System.out.println("当前对象活着的");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("this is finalize ");
        FinalizeTest.finalizeTest = this;
    }

    public static void main(String args[]) throws InterruptedException {

        finalizeTest = new FinalizeTest();

        finalizeTest = null;
        System.gc();
      //因为finalize的线程优先级很低，所以暂停，以等待它的结束
        Thread.sleep(500);
        if(finalizeTest != null){
            finalizeTest.isAlive();
        }else {
            System.out.println("I am dead");
        }

        finalizeTest = null;
        System.gc();
        Thread.sleep(500);
        if(finalizeTest != null){
            finalizeTest.isAlive();
        }else {
            System.out.println("I am dead");
        }

    }
}
```

```
运行结果
this is finalize 
当前对象活着的
I am dead
```

从上面的结果可以看到，第一个gc的时候，对象还是存在的，但是第二次gc对象就不存在了，这是因为finalize方法只会被执行一次，在第一次执行finalize的时候，对象被成功救活了，但是第二次不能执行finalize方法了，所以对象就被回收了。

### 垃圾回收算法

#### 分代收集理论

目前市面上大多数的垃圾回收器都是遵循了**分代收集**的理论，具体的设计原则就是将java对划分出不同的区域，根据对象年龄的大小，将其分配到不同的区域

目前分代理论放到现在的商用java虚拟机中一般有**新生代**和**老年代**。

但是在这个理论上存在一个问题----**跨代引用**，如果一个新生代对象引用了一个老年代的对象，由于老年代对象难以消亡，所以新生代对象随着年龄的增长，最终晋升到老年代。

依据这条假说，我们不应该为了少量的跨代引用去扫描这个老年代，只需要在新生代上建立一个全局的数据结构(**记忆集**)，该结构将老年代划分成若干个小块，标识出哪些小块存在跨代引用，在年轻代发生Minor
GC的时候，只有包含跨代引用的块才会被加入到GC Roots中。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，如果这种结构记录的全部含跨代引用对象的实现方式，那么会占用大量的内存，所以在实际的实现中采用的是判断非收集区域含有指向收集区域的指针即可。

#### 标记-清除算法

标记可以被清除的的对象，然后统一回收，也可以标记不可以被清除的对象，统一回收未被标记的对象。

**缺点：**

1. 随着对象数量的不断增长，收集的效率也在不断的降低
2. 大量不连续的空间被清理，导致空间的浪费

<img src="https://gitee.com/gluten/images/raw/master/images/202110212153648.png" alt="image-20211019221159527" style="zoom:30%;" />

#### 标记-复制算法

标记哪些对象是可以存活的，将这些对象统一复制到另外一个区域。

该算法一般在年轻代中实现，将年轻代分为Eden、from和to三块区域，三块的比例为8:1:1，如果对象在复制的过程中大于from或者to的内存，那么该对象会被移动到老年代。

缺点：

​ 需要额外的空间来保留存活的对象，存活的对象越多，需要的空间就越大

<img src="https://gitee.com/gluten/images/raw/master/images/202110212153452.png" alt="image-20211019221458265" style="zoom:33%;" />

#### 标记-整理算法

标记复制算法在对象较多的时候，进行复制操作效率会降低，所以在老年代对象大量存活的情况下，就不适合采用这种算法。

标记整理算法中标记过程和标记清除是一样的，但是后续的整理是将存活的对象移动到空间的一端。 然后清理表边界以外的内存。

**缺点：**

​ 因为在整理的过程中，需要移动对象，并将所有引用这些对象的地方都更新，这是一项极其复杂的操作，所以在移动的过程中用户程序是暂停操作的，也就是常说的STW(Stop The World)

<img src="https://gitee.com/gluten/images/raw/master/images/202110212153955.png" alt="image-20211019222410692" style="zoom:33%;" />

### 垃圾回收器

<img src="https://gitee.com/gluten/images/raw/master/images/202110212153222.png" alt="image-20211019223743571" style="zoom:33%;" />

上图代表的是各种垃圾回收器的组合，可以先记住这个图，因为在后面介绍完垃圾回收器后，就可以清楚的知道为什么这么组合了。

#### Serial收集器

Serial（串行），顾名思义这是一个单线程的收集器（新生代），这个收集器在执行的时候，其他所有的线程都需要暂停，等待它收集结束。

虽然说目前市面上到处都是高性能的服务器，但是单线程也有它的好处，在一些桌面环境中，能给到用户程序的内存很少，这时候使用该收集器是一个不错的选择，所以说在资源受限的环境下，该收集器反而有着优于其他收集器的性能，到目前为止它依然是HtoSpot虚拟机运行在客户端模式下的默认新生代收集器。

#### ParNew收集器

该收集器从实质上来说只是Serial收集器的并行版本。除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器一致。**注意**ParNew包含Serial和Serial
Old,所以说ParNew既是新生代收集器也是老年代收集器。

该收集器是不少运行在服务端的虚拟机的首选，一方面因为它的性能，另外一方面是因为目前只有它可以和CMS收集器配合工作。

**<span style='color:red'>CMS作为老年代的收集器，却无法和新生代的收集器Parallel Scavenge收集器配合工作，所以在激活CMS后，ParNew是作为默认的新生代收集器使用的。</span>**

#### Parallel Scavenge收集器

该收集器作为一个新生代的收集器，采用同样是标记复制算法。也是能够并行收集的收集器，那么它和ParNew的区别在哪呢？

CMS等收集器的关注点在尽可能的缩短垃圾回收时用户线程的停顿时间，但是Parallel Scavenge收集器注重的是吞吐量。 $$ 吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+垃圾收集时间} $$
高吞吐量可以更高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

可以通过一些参数去更精确的控制吞吐量

```
-XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
-XX:GCTimeRatio 设置吞吐量的大小
```

Parallel Scavenge自身架构中有老年代的收集器---- PS MarkSweep，并非直接调用的Serial Old收集器，但是该收集器和Serial Old收集器的实现几乎是一样的，所以在很多地方都是直接介绍的Serial
Old收集器

#### Serial Old收集器

作为Serial收集器的老年代版本，它同样是一个单线程的收集器，使用标记整理算法，它的意义主要是供客户端使用，如果在服务端使用，主要有两个途径，第一个是在JDK5以及之前的版本中，配合Parallel
Scavenge收集器使用，第二个途径是作为CMS收集器发生失败后的后备预案。

#### Parallel Old收集器

该收集器作为Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记整理算法，是从JDK6开始提供的。在此之前Parallel Scavenge收集器一直处于一个尴尬的境地，因为老年代收集器只有Serial
Old单线程收集器配合它工作。

#### CMS（Concurrent Mark Sweep）收集器

作为一款以获取最短回收停顿时间为目标的收集器，目前很大一部分的java应用都会采用该收集器。

从命名来来看，可以清楚的知道该收集器的算法使用的是标记清除算法。它的运作方式主要包含了四步：

1. <span style='color:red'>初始标记</span>

   标记GC Roots能直接关联到的对象，速度很快

2. 并发标记

   从关联到的对象开始遍历整个对象图，耗时很长，但是不需要停顿用户线程

3. <span style='color:red'>重新标记</span>

   修正并发标记期间，因为用户线程运作而导致产生变动的那一部分对象

4. 并发清除

   清除已经被标记的对象

初始标记和重新标记需要停顿用户线程

在并发标记期间，虽然不会停顿用户线程，但是自身标记也会使用到一部分线程，所以会导致用户线程变慢。

由于CMS无法处理**浮动垃圾（在并发标记和并发清楚阶段还是会产生垃圾的，但是CMS无法处理这些垃圾，只好留在下一次回收的时候处理）**，所以有可能导致**Con-current Mode Failure**进而导致Full
GC的产生，这次回收的时候老年代会使用Serial Old作为回收器。

因为需要留下一部分空间提供给用户线程使用，所以CMS收集器当老年代使用了68%（JDK6的是改为了92%）的时候就会被激活，当然这个值是可以通过参数去修改的。

#### Garbage First收集器

作为一款新型的收集器，G1不再是基于分代去处理垃圾，而是根据哪块内存存放的垃圾最多，回收效益最大去进行回收的，这就是G1收集器的Mixed GC模式。

虽然GC仍是遵循分代收集理论去设计的，但是其堆内存的布局与其他收集器有着很明显的区别，G1是将连续的java堆划分成多个大小相等的独立区域（Region），每个区域都可以根据需要，扮演新生代的Eden、Survivor、或者老年代空间。收集器可以根据扮演不同角色的Region采用不同的策略去处理。

Region中有一类特殊的Humongougs区域专门用来存储大对象，G1认为只要大小超过Region容量的一半都判定为大对象，一个Region的取值范围在1MB^32MB之间，且应为2的N次幂，而那些看作大对象的都会被放在N个连续的Humongous
Region之中，G1的大多数行为会把这些区域看作是老年代的一部分。

从整体上来看G1可以看作是标记整理算法，但是在局部上有可以看作是标记复制算法。

G1的收集步骤大概分为四步：

1. <span style='color:red'>初始标记</span>

   标记GC Roots能够直接关联到的对象

2. 并发标记

   根据可达性分析，递归扫描整个堆，耗时较长

3. <span style='color:red'>最终标记</span>

   处理并发阶段结束后仍遗留下来的少量STAB（原始快照）记录

4. <span style='color:red'>筛选回收</span>

   对各个Region进行回收价值和成本的排序，根据用户期望的停顿时间来指定回收的计划，将决定回收的那部分存活对象移动到另外一个空的Region中，再清理整个旧的Region空间

所以说在整个过程中只有并发标记阶段，用户线程没有停顿

### 内存分配

大多数情况下，对象会在新生代的Eden区域中进行分配，当Eden区域没有足够的空间进行分配的是，虚拟机将会发起一次Minor GC。

一个对象想要进入老年代有以下几种情况：

- 对象的年龄达到了指定的要求，如果没有修改年龄大小的话，默认是15
-
大对象（占用大量连续空间的对象），该对象因为需要很多连续的空间，但是年轻代没有足够的空间让它使用，所以会被分配到老年代。另外一种情况就是虚拟机可以指定超过一定大小的对象直接进入老年代，因为该对象在年轻代中进行复制的时候会产生大量的内存复制操作，浪费资源。
- 如果在Surivor中多个年龄相同的对象大小总和大于Survivor空间的一半，那么年龄大于或者等于该年龄的对象就可以直接进入到老年代，无需等到指定的年龄大小

在发生Minor GC之前，虚拟机必须坚持老年代最大可以的连续空间是不是大于新生代所有对象总空间，如果成立，那么可以确保这一次的Minor GC是安全的，如果不成立，虚拟机会先查看参数**_XX:
HandlerPromotionFailure**是否允许担保失败，如果允许，那么会继续检查老年代的最大可用空间是否大于**<span style='color:red'>历次晋升到老年代对象的平均大小</span>**
，如果检查的结果是大于，那么会进行一次Minor GC，即时这次GC是有风险的，如果小于或者参数设置的是不允许冒险，那么会进行Full GC

